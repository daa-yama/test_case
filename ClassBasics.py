# # 
#   【結論】関数とクラスの決定的な違い

#   ここまでの話で、最初の疑問に戻りましょう。

#   「関数とClassの違い、どちらも繰り返し使えるものと認識しているが何が違う？」

#   あなたの認識は、半分正解です。どちらも「再利用性」のためにありますが、その再利用の仕方が根本的に違います。

#    * 関数の再利用性とは、「同じ『アクション』を、違うデータに対して繰り返し使える」ということ。
#        * make_juice() という一つの関数（道具）を、リンゴやオレンジ（違うデータ）に対して使い回せます。
#        * 主役はあくまで「処理（アクション）」です。

#    * クラスの再利用性とは、「同じ『設計図』から、違う『モノ』を、何個でも繰り返し作れる」ということ。
#        * Player という一つのクラス（設計図）から、たろう君やはなこさん（違うモノ）を何人も生み出せます。
#        * 主役はあくまで「モノ（オブジェクト）」です。

#   一言でいうと、
#    * 関数は、「処理」のレシピ。
#    * クラスは、「モノ」の設計図。

#   クラスは、「データ」と、そのデータに関連する「処理」を、一つのオブジェクトとしてまとめてカプセル化することで、プログラムを、より現実世界の「
#   モノ」の集まりとして捉えやすくし、整理しやすくするための、高度な整理術なのです。



# ここでは「関数とクラスの違いがよくわからない」を解消しつつ、「どっちをいつ使うべきか」まで、初学者でも迷わない基準でまとめます。
# 目標は**“関数＝動詞、クラス＝名詞＋その名詞ができること（動詞）の束”**という感覚を体に入れることです。

# 結論の先取り：最短理解
# 	•	関数は「入力 → 処理 → 出力」の1回の仕事を名前でまとめたもの。
# 	•	例：tax(price) は価格を受け取り、税額を返す。
# 	•	**状態（メモリに保持し続ける値）**は基本持たない。
# 	•	クラスは「モノ（データ＝名詞）とそのモノができること（操作＝動詞）をひとまとめにした設計図」。
# 	•	例：VendingMachine は「投入金額」「在庫」といった状態を持ち、insert(), buy() といった振る舞いで状態を継続的に更新する。
# 	•	クラスから作る実体をインスタンスと呼ぶ。インスタンスごとに状態が独立。

# 迷ったらチェック：
# “同じデータに対する複数の操作を、繰り返し＆一貫したルールで行いたい？”
# → Yes ならクラス向き。 No で「単発の変換」なら関数でOK。

# 	•	関数＝動詞（単発の変換）。状態を持たないほど強い。
# 	•	クラス＝名詞＋動詞の束（設計図）。状態を安全に保ち、一貫性を守る。
# 	•	実務のコツ：
# 	1.	最小の関数で始める
# 	2.	同じデータに触る関数が増えたらクラス化
# 	3.	クラスでは「状態」「不変条件（前提）」「公開API（外から呼ばれるメソッド）」を意識
def format_part(title, part_no, url):
    """
    タイトル・品番・URLを受け取り、
    タブ区切りの文字列にして返す関数
    """
    return f"{title}\t{part_no}\t{url}"


# 使用例
title = "エアクリーナー"
part_no = "17801-31120"
url = "https://example.com/item/17801-31120"

formatted = format_part(title, part_no, url)
print(formatted)
# → エアクリーナー    17801-31120    https://example.com/item/17801-31120
class ClipBuffer:
    def __init__(self):
        # 内部状態を初期化
        self.reset()

    def reset(self):
        """内部状態をリセット"""
        self.title = None
        self.part_no = None
        self.url = None

    def push_title(self, title):
        """タイトルをセット"""
        self.title = title

    def push_part(self, part_no):
        """品番をセット"""
        self.part_no = part_no

    def push_url(self, url):
        """URLをセット"""
        self.url = url

    def flush(self):
        """
        現在の状態を「タイトル\t品番\tURL」にまとめて返す。
        返したあと、内部状態をリセット。
        """
        if not (self.title and self.part_no and self.url):
            return "必要な情報が揃っていません。"

        result = f"{self.title}\t{self.part_no}\t{self.url}"
        self.reset()
        return result


# 使用例
buffer = ClipBuffer()

# コピーする順番はバラバラでもOK
buffer.push_url("https://example.com/item/17801-31120")
buffer.push_part("17801-31120")
buffer.push_title("エアクリーナー")

# flushでまとめて1行に
print(buffer.flush())
# → エアクリーナー    17801-31120    https://example.com/item/17801-31120

# 再利用（状態がリセットされている）
buffer.push_title("フォグランプカバー")
buffer.push_part("57731FN200")
buffer.push_url("https://example.com/item/57731FN200")
print(buffer.flush())
# → フォグランプカバー    57731FN200    https://example.com/item/57731FN200






# メンターに関数とクラスの理解が違うかもと言われた。関数（メソッド）を管理するためにクラスを使うイメージ。

# クラスの例え
# スプレッドシートクラスを作成
# ・スプレッドシートを読込むメソッド（関数）
# ・スプレッドシートに書込むメソッド（関数）
# ・スプレッドシートのcolumnを読込むメソッド（関数）
# ・スプレッドシートのワークシートを、新しく作るメソッド（関数）

# これらを一元管理できる。
# クラスに渡すのはスプシのURLやセキュリティなど

# 理解できるように解説して


# なるほど！メンターさんがおっしゃっているのは、

# 「関数をバラバラに使うより、クラスを使って一元管理した方が整理されて分かりやすい」

# ということです。
# そのイメージを「スプレッドシート操作」に例えて説明しますね。

# ⸻

# 1. 関数とクラスの違いをシンプルに
# 	•	関数（function / method）
# → 1つの処理のまとまり。
# 例：「シートを読み込む」「セルに書き込む」など。
# 	•	クラス（class）
# → 関数やデータをまとめる「箱」「設計図」。
# 例：「スプレッドシート操作専用のリモコン」を作る。

# つまり、クラスは「処理をまとめる器」。
# 複数の関数を関連性のあるグループとして管理するために使うイメージです。

# ⸻

# 2. スプレッドシートを例にすると…

# 例えば、Googleスプレッドシートを操作するには色んな処理があります。
# 	•	シートを読み込む
# 	•	シートに書き込む
# 	•	特定の列を読む
# 	•	ワークシートを新規作成する

# これを「関数だけ」で管理すると、こんな感じです：

# def read_sheet(url):
#     ...
# def write_sheet(url, data):
#     ...
# def read_column(url, col):
#     ...
# def create_worksheet(url, name):
#     ...

# → すべての関数で url を毎回渡す必要があり、管理がバラバラ。

# ⸻

# 3. クラスでまとめると…

class Spreadsheet:
    def __init__(self, url, security_token):
        self.url = url
        self.security_token = security_token

def read(self):
    print(f"{self.url} を読み込みました")

    def write(self, data):
        print(f"{self.url} に {data} を書き込みました")

    def read_column(self, col):
        print(f"{self.url} の {col}列を読み込みました")

def create_worksheet(self, name):
    print(f"{self.url} に新しいシート {name} を作成しました")


# ⸻

# 4. 実際の使い方

# # スプレッドシートを操作するオブジェクトを作る
# sheet = Spreadsheet("https://example.com/sheet123", "tokenABC")

# # 以降は「sheet」というリモコンで操作
# sheet.read()
# sheet.write("データ")
# sheet.read_column("A")
# sheet.create_worksheet("売上データ")

# → url や security_token は最初に渡すだけ。
# 以降は「sheet」という一つのオブジェクトを通じて、関連する処理を全部まとめて使える。

# ⸻

# 5. イメージまとめ
# 	•	関数だけ：バラバラの道具。使うたびにURLを渡さなきゃいけない。
# 	•	クラス：スプレッドシート専用の「リモコン」。必要な情報（URLやセキュリティ）は最初に登録しておけばOK。ボタン（メソッド）を押すだけで一連の操作ができる。

# ⸻

# 💡 つまり「クラスは、関数をまとめて管理するための器」という理解で大丈夫です。
# スプレッドシートに例えると、
# **「操作ボタンをまとめたリモコンを自分で作る」**のがクラスです。

# ⸻

